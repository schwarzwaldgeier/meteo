#!/usr/bin/perl -w

BEGIN {push @INC, "/var/www/BERGSTATION/wetterstation/"}

my $basepfad = "/var/www/BERGSTATION/wetterstation/";
my $logpfad = "/var/www/BERGSTATION/LOGS/wetterstation/";

use Carp;
use strict;
use Weather::Archive;
use LWP::Simple;


#use Device::SerialPort 0.06;
use Device::SerialPort 0.05;
#use Win32::SerialPort;
#my $port = "COM1";
my $port = "/dev/ttyS1";

my $PortObj;
$PortObj = Device::SerialPort->new ($port) or die "Can't start $port\n";
#$PortObj = Win32::SerialPort->new ($port) or die "Can't start $port\n";

$PortObj->baudrate(9600);
$PortObj->parity("odd");
$PortObj->databits(8);
$PortObj->stopbits(1);
$PortObj->parity_enable(0);

$PortObj->handshake("dtr");

use Weather::Conversions qw( UnitsTemp UnitsPres UnitsWind UnitsRain );

require "weather_wmr918.pl";

my $print = 0;
if (defined @ARGV && $ARGV[0] eq '-p') {$print = 1;}

# Setup für die Sensoren Konversionen die ausgeführt werden
my %process = ( 'wind' => [['WindGustSpeed',\&UnitsWind], ['WindAvgSpeed',\&UnitsWind], ['WindChill',\&UnitsTemp]],
                'rain' => [['RainRate',\&UnitsRain], ['RainTotal',\&UnitsRain], ['RainYest',\&UnitsRain]],
				'outdoor' => [['TempOutdoor',\&UnitsTemp], ['DewOutdoor',\&UnitsTemp]],
				'indoor' => [['TempIndoor',\&UnitsTemp], ['DewIndoor',\&UnitsTemp], ['Barom',\&UnitsPres]],
				'minutes' => [],
				'date' => [],
              );
# Aliase
my %aliases = ( 'wind' => [['WindGustSpeed','WGS'], ['WindAvgSpeed','WAS'], ['WindChill','WC'], ['F1Wind','F1W'],['WindGustDir','WD']],
                'rain' => [['RainRate','RR'], ['RainTotal','RT'], ['RainYest','RY'], ['F1Rain','F1R'], ['F3Rain','F3R'],['ResetDateTime','RS']],
				'outdoor' => [['TempOutdoor','TO'], ['DewOutdoor','DO'], ['F1Outdoor','F1O'],['HumidOutdoor','HO']],
				'indoor' => [['TempIndoor','TI'], ['DewIndoor','DI'], ['Barom','BR'], ['F1Indoor','F1I'], ['F7Indoor','F7I'], ['F8Indoor','F8I'], ,['HumidIndoor','HI']],
				'minutes' => [],
				'date' => [],
              );
# CHANGE - Forecast oben				'indoor' => [['TempIndoor','TI'], ['DewIndoor','DI'], ['Barom','BR'], ['F1Indoor','F1I'], ['F7Indoor','F7I'], ['F8Indoor','F8I'], ['Forecast','FCS'],['HumidIndoor','HI']],

# Namen der Hash-Arrays für die Mitglieder jeder Sensor-Gruppe
my %groups = ( 'wind' => ['F1Wind', 'WindGustDir', 'WindGustSpeed', 'WindAvgSpeed', 'WindChill',],
               'rain' => ['F1Rain', 'RainRate', 'F3Rain', 'RainTotal', 'RainYest', 'ResetDateTime',],
			   'outdoor' => ['F1Outdoor', 'TempOutdoor', 'HumidOutdoor', 'DewOutdoor',],
			   'indoor' => ['F1Indoor', 'TempIndoor', 'HumidIndoor', 'DewIndoor', 'Barom', 'F7Indoor', 'F8Indoor',],
			   'minutes' => ['Minutes',],
			   'date' => ['F1Date', 'HH:MMDDYY',],
             );
# CHANGE - Forecast oben			   'indoor' => ['F1Indoor', 'TempIndoor', 'HumidIndoor', 'DewIndoor', 'Barom', 'Forecast', 'F7Indoor', 'F8Indoor',],

# So, erst mal alles auf Null -> weniger Fehler, schöneres Leben :-)
my %weather = ( 'F1Wind' => 0,
             'WindGustDir' => 0,
             'WindGustSpeed' => 0,
             'WindAvgSpeed' => 0,
             'WindChill' => 0,
             'F1Rain' => 0,
             'RainRate' => 0,
             'F3Rain' => 0,
             'RainTotal' => 0,
             'RainYest' => 0,
             'ResetDateTime' => 0,
             'F1Outdoor' => 0,
             'TempOutdoor' => 0,
             'HumidOutdoor' => 0,
             'DewOutdoor' => 0,
             'F1Indoor' => 0,
             'TempIndoor' => 0,
             'HumidIndoor' => 0,
             'DewIndoor' => 0,
             'Barom' => 0,
             'F7Indoor' => 0,
             'F8Indoor' => 0,
             'Minutes' => 0,
             'F1Date' => 0,
             'HH:MMDDYY' => 0,
);
# CHANGE - Forecast oben             'Forecast' => 0,


my $gotit = "";
my $count_in;
my $debug=0;
my $debuga=0;
my $keepit="";
my $sleep = 4;
my $avgsum = 1; my $avgcnt = 1;

use vars '%weather';
my $logfile = $logpfad . 'log.txt';
my $archive = $logpfad . 'arch.txt';
my $Wobj = Weather::Archive->new($logfile, $archive);
my $lite = 'A2';
my $cmd = 'J';

# ----------- von der alten Software ----------------------- #
my $initialstart = 1;            # lets the serial buffer run to NULL when program comes up (do not change)
my $timecontrol = time();        # time for exit and restart when nothing happens (do not change)
my $timereset =  600000;         # program will restart when $timereset seconds nothing happens on serial
my $start = 0;                   # value of sequence (do not change)
my $newset = 0;                  # switch when new data sentence starts (do not change)
my $outi = "";                   # output data from serial device stored in this one (do not change)
my @adat = ();                   # output data is pushed into this array (do not change)
my $content = "";                # feedback of web-db-interface (do not change)
my $interval = 4;                # interval after how many sentences data is written do DB
my $intervaltime;                # output var only (how many seconds did $interval use) (do not change)
my $wd_u = 0;			 # winddirection vector (do not change)
my $wd_v = 0;			 # winddirection vector (do not change)
my $wd_w = 0;			 # winddirection angle (do not change)
my $pi = 3.141592645;		 # PI :-)
my $wd = 0;                      # winddirection is being counted up here (do not change)
my $ws = 0;                      # windspeed is being counted up here (do not change)
my $ws_max = 0;			 # windspeed maximum (do not change)
my $pr = 0;                      # atmospheric pressure is being pressure counted up here (do not change)
my $te = 0;                      # temperature is being counted up here (do not change)
my $lwd = 0;                     # winddirection for logging purposes (do not change)
my $lws = 0;                     # windspeed for logging purposes (do not change)
my $lpr = 0;                     # atmospheric pressure for logging purposes (do not change)
my $lte = 0;                     # temperature for logging purposes (do not change)
my $wdtmp = 0;
my $wdtmp1 = 0;
# -----------------------------------------------------------#

$Wobj -> writewhen(1,5); # Minuten, Einträge
$Wobj -> rotate_when(10); # So viele Minuten nach der Geisterstunde rotieren wir

#$SIG{'INT(1)'} = sub {$Wobj -> flush; sleep 3; die "usr1 kill signal recieved\n";};
#$SIG{'INT(2)'} = sub { $Wobj -> flush;};

#---------------- RS232-Leseschleife START ------------------
while (1) {
	($count_in, $gotit) = $PortObj->read(100);
	#if ($gotit eq "") {
	#	print "Out ouf sync...\n";
	#	sleep 60;
	#	exit;
	#}
	sleep $sleep;
	next if $count_in == 0;
	$gotit = $keepit . $gotit if defined $keepit;
	$weather{'Group'} = undef;
	$keepit = &read_wmr918( $gotit, \%weather, $debug);
	&process if defined $weather{'Group'};
}
#---------------- RS232-Leseschleife ENDE _------------------

# Hier definieren wir dei Sensor-Konversionen die ausgeführt werden

sub process {
	# First do any desired units conversions
	print "Process Group = $weather{'Group'}\n" if $debuga;
	print "Process Group = $weather{'Group'}\n";
	print "---------------------------------------------\n";
		foreach (@{$process{$weather{'Group'}}}) {
		$weather{$_->[0]} = &{$_->[1]}($weather{$_->[0]});
	}

	# Hinzufügen zum Sammler und Filter
	foreach (@{$aliases{$weather{'Group'}}}) {
		#if ($_->[0] eq 'WindGustDir' && $weather{'WindGustSpeed'} == 0) {
			# Windrichtung nicht ausgeben wenn speed = 0
		#}
		#else {
			$Wobj->add($weather{$_->[0]},$_->[1]);
		#}
	}

	if ($weather{'Group'} eq "outdoor") {
		foreach (@{$groups{$weather{'Group'}}}) {
			if($_ eq "TempOutdoor") {
				$te = ($weather{$_} - 32) * 5 / 9;
			}
		}
	}
	if ($weather{'Group'} eq "indoor") {
		foreach (@{$groups{$weather{'Group'}}}) {
			if($_ eq "TempIndoor") {
				$te = ($weather{$_} - 32) * 5 / 9;
			}
			if($_ eq "Barom") {
				$pr = $weather{$_};
			}
		}
	}
	if ($weather{'Group'} eq "wind") {
		$start++;
		foreach (@{$groups{$weather{'Group'}}}) {
			if($_ eq "WindGustDir") {
			#    if($weather{$_} > 140) {
			#	$wdtmp1 = $weather{$_} - 140;
			#	$wd = $weather{$_} + $wd - 140;
			#	$wdtmp = $wd;
			#    } else {
			#	$wdtmp1 = $weather{$_} + 220;
			#	$wd = $weather{$_} + $wd + 220;
			#	$wdtmp = $wd;
			#    }
			    #$wdtmp = $weather{$_} + $wd;
			    $wd += $weather{$_};
                            $wdtmp1 = $weather{$_};
				$wd_u += sin($wdtmp1 * $pi / 180);
				$wd_v += cos($wdtmp1 * $pi / 180);
			    print "tmp: " . $wdtmp1 . "\n";
			}
			if($_ eq "WindGustSpeed") {
				$ws += $weather{$_};
				if ($weather{$_} > $ws_max) {
					$ws_max = $weather{$_};
				}
			}
		}
        	if ($start == $interval) {
        	    $wd = int($wd/$interval);
        	    $ws = int($ws/$interval*1.609344);
        	    $ws_max = int($ws_max*1.609344);
        	    $te = int($te);
        	    #$pr = int($pr/$interval);

        	    $wd_u = $wd_u / $interval;
        	    $wd_v = $wd_v / $interval;
        	    $wd_w = atan2(abs($wd_u),abs($wd_v)) * 180 / $pi;

        	    if ( ($wd_u >= 0) && ($wd_v >= 0) ) {
        	    	$wd_w = $wd_w;
        	    }
        	    if ( ($wd_u >= 0) && ($wd_v < 0)  ) {
        	    	$wd_w = 180 - $wd_w;
        	    }
        	    if ( ($wd_u < 0) && ($wd_v >= 0)  ) {
        	    	$wd_w = 360 - $wd_w;
        	    }
        	    if ( ($wd_u < 0) && ($wd_v < 0)   ) {
        	    	$wd_w = 180 + $wd_w;
        	    }
        	    $wd_w = int($wd_w);
				
				$wd_w = $wd_w + 90;
				if ($wd_w > 360) {
					$wd_w = $wd_w - 360;
				}
				
				
        	    logme($logfile,"Averaged winddirection:         " . $wd_w . " Grad");
        	    logme($logfile,"Averaged windspeed:             " . $ws . " km/h");
        	    logme($logfile,"Maximum windspeed:              " . $ws_max . " km/h");
        	    logme($logfile,"Averaged temperature:           " . $te . "° C");
        	    logme($logfile,"Averaged athmospheric pressure: " . $pr . " hpa");
        	    #logme($logfile,"Measurement period:             " . $intervaltime . " seconds");
        	    logme($logfile,"=====================================");
        	    logme($logfile,"sending data do web-db...");

        	    $content = get("http://para:geier\@www.lenkungsgruppe.de/v3/wetterstation/insert.php?wd=$wd_w&ws=$ws&te=$te&pr=$pr&ms=$ws_max");
        	    print "http://para:geier\@www.lenkungsgruppe.de/v3/wetterstation/insert.php?wd=$wd_w&ws=$ws&te=$te&pr=$pr&ms=$ws_max";
        	    logme($logfile,$content);
                    $content = get("http://wetter:merkur11\@www.gsvbaden.de/_extphp/wetterstation/insert/insert.php?wd=$wd_w&ws=$ws&te=$te&pr=$pr&ms=$ws_max");
                    print "http://wetter:merkur11\@www.gsvbaden.de/_extphp/wetterstation/insert/insert.php?wd=$wd_w&ws=$ws&te=$te&pr=$pr&ms=$ws_max";
                    logme($logfile,$content);

                    $content = get("http://localhost:81/wetterstation/insert.php?wd=$wd_w&ws=$ws&te=$te&pr=$pr&ms=$ws_max");
                    print "http://localhost:81/wetterstation/insert.php?wd=$wd_w&ws=$ws&te=$te&pr=$pr&ms=$ws_max";
                    logme($logfile,$content);
					
					
        	    # cleaning up
        	    $wd = 0;
        	    $ws = 0;
        	    #$te = 0;
        	    #$pr = 0;
        	    $wd_v = 0;
        	    $wd_u = 0;
        	    $wd_w = 0;
        	    $ws_max = 0;
        	    $start = 0;
        	}

	}

	# Einträge ausgeben
	if ($print) {
		my @t = localtime(time);
		my $dat = ($t[5]+1900) . "-" . ($t[4]+1) . "-" . $t[3] . "T" . $t[2] . ":" . $t[1] . ":" . $t[0];
		print "$dat\n";
		foreach (@{$groups{$weather{'Group'}}}) {
			print " $_ = $weather{$_} \n";
		}
		print "\n";
	}
}


sub logme {
	print $_[1] . "\n";
}

=head1

Collect and archive weather data from a WMR918

weather_clean <-p>
	-p : print a copy of data to STDOUT

Requires
	Weather::Archive.pm
	Device::SerialPort.pm
	Weather::Conversions.pm
	weather_wmr918.pl

Expects the serial port to be softlinked to:
	/dev/wmr918

program may be controlled with USR signals :

kill -SIGUSR1 pid : this will flush the buffer and exit the program
kill -SIGUSR2 pid : this will flush the buffer and continue the program

A new archive file is written each day just after midnight.

Note that the archive and log files are hard-coded. Yeah, I'm lazy...

The archive files may be read with Weather::ReadArch

Alan Jackson, Copyright 2000, released under the same conditions as perl.
weatherman@ajackson.org

=cut
